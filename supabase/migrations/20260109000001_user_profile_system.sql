-- Up Migration

-- 1. UPDATE profiles table
alter table public.profiles
add column if not exists full_name text,
add column if not exists headline text,
add column if not exists bio text,
add column if not exists location text,
add column if not exists experience_level text,
add column if not exists updated_at timestamptz default now();

-- Ensure users can UPDATE their own profile fields (Already covered by RLS "Users can update own profile")
-- We just need a trigger to update 'updated_at' on change
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger on_profiles_updated
  before update on public.profiles
  for each row execute procedure public.handle_updated_at();


-- 2. CREATE user_cvs table
create table if not exists public.user_cvs (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users(id) not null,
  file_path text not null,
  original_filename text,
  uploaded_at timestamptz default now()
);

alter table public.user_cvs enable row level security;

-- RLS: Users can SELECT own CVs
create policy "Users can view own CVs"
  on public.user_cvs for select
  using ( auth.uid() = user_id );

-- RLS: Users can DELETE own CVs
create policy "Users can delete own CVs"
  on public.user_cvs for delete
  using ( auth.uid() = user_id );

-- RLS: INSERT is RESTRICTED to Service Role (Edge Function)
-- No insert policy for authenticated users.


-- 3. STORAGE BUCKET CONFIGURATION
-- We need to ensure the 'cv-uploads' bucket exists.
-- Storage objects are managed via the 'storage.objects' and 'storage.buckets' tables in the 'storage' schema.

insert into storage.buckets (id, name, public)
values ('cv-uploads', 'cv-uploads', false)
on conflict (id) do nothing;

-- Storage RLS
-- Users can read their own files?
-- Actually, we want download via SIGNED URL ONLY from Edge Function.
-- So we might NOT allow public/authenticated read access directly via RLS, or strict RLS.
-- If we use Signed URLs, the underlying RLS must allow the signer (Service Role) to sign?
-- Signed URLs usually bypass RLS if generated by Admin, OR they work if RLS allows the user.
-- Let's stick to: "Users can only access via Edge Function".
-- So NO RLS policy for SELECT for users on 'cv-uploads'.
-- Edge Function (Service Role) will generate the URL.

-- However, for the Edge Function to UPLOAD using Service Role, it has admin rights.
-- So we don't strictly need RLS policies for the USER if the USER never interacts with Storage directly.
-- CONFIRMATION: "Access: Upload via Edge Function, Download via signed URL".
-- Correct: Zero Trust Frontend. Frontend NEVER calls supabase.storage.from('...').upload().
-- So we generally don't need user policies here. Good.

-- 4. CLEANUP Trigger helper (optional)
-- When a user deletes their account, we want cascading delete.
-- 'user_cvs' references 'auth.users', so if auth user is deleted, it cascades?
-- Yes, if 'references auth.users(id) on delete cascade'.
-- Let's check our constraint.
alter table public.user_cvs
drop constraint if exists user_cvs_user_id_fkey,
add constraint user_cvs_user_id_fkey
  foreign key (user_id)
  references auth.users(id)
  on delete cascade;

alter table public.profiles
drop constraint if exists profiles_id_fkey,
add constraint profiles_id_fkey
  foreign key (id)
  references auth.users(id)
  on delete cascade;

-- Now 'auth.admin.deleteUser(id)' will automatically wipe 'profiles' and 'user_cvs' rows.
-- The Storage Files, however, are NOT automatically deleted by Postgres Cascade.
-- The Edge Function `delete-account` MUST handle storage cleanup manually.
